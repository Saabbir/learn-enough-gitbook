---
description: >-
  A clear, in-depth explanation of how npm stores, resolves, and manages
  packages.
---

# 4️⃣ CHAPTER 4 — Inside node\_modules: How Dependencies Actually Work

## 1. Introduction

Almost every new Node.js developer asks:

* What is inside `node_modules`?
* Why is it so large?
* Why are there so many nested folders?
* How does Node know where to find packages?
* Why do two versions of the same package exist?
* Why do some tools create flatter folder structures?

This chapter answers all of these questions in a structured, beginner-friendly way.\
By the end, you will understand exactly how dependency resolution works in Node.js and npm.

## 2. What Is `node_modules`?

`node_modules` is a directory created by npm (or yarn, pnpm) to store all the dependencies your project needs.

It contains:

* Packages you installed
* Their dependencies
* Their dependencies’ dependencies
* Deep nested versions of libraries

It is a **self-contained ecosystem** for your project.

`node_modules` is necessary because JavaScript applications depend on many small libraries.\
A typical React project can easily install **500–2000 packages**.

## 3. Why Does `node_modules` Get So Big?

There are several reasons:

### 1. Every package can have its own dependencies

Example:\
You install Express → Express installs 40+ other packages.

### 2. Many packages depend on tiny utility libraries

Packages like `is-number`, `kind-of`, `safe-buffer` are installed everywhere.

### 3. Different versions of the same package may be needed

One dependency may need lodash v4 while another requires v3.\
npm will install both.

### 4. Even a small project uses dozens of tools

* bundlers
* linters
* test frameworks
* build tools
* transcompilers

All exist inside `node_modules`.

## 4. How Node.js Resolves Modules (The Search Algorithm)

When you import a module:

```js
const express = require("express")
```

Node.js follows a simple resolution algorithm:

### Step 1 — Check if it's a core module

Examples:

* fs
* http
* path\
  If yes, load it directly.

### Step 2 — Check local files

If you write:

```js
require("./utils")
```

Node checks:

* ./utils.js
* ./utils.json
* ./utils/index.js

### Step 3 — Search inside node\_modules

Node looks inside:

```
your-project/node_modules/express
```

If not found:

### Step 4 — Move upward

Node climbs up directories:

```
your-project/node_modules
parent-folder/node_modules
parent-of-parent/node_modules
...
```

Stops at the system root.

This upward search allows nested dependencies to work naturally.

## 5. The Structure of node\_modules

Let’s say you install:

```
npm install express axios
```

Your node\_modules may look like:

```
node_modules/
  express/
  axios/
  accepts/
  array-flatten/
  body-parser/
  debug/
  ...
```

Many folders exist because Express depends on many utilities.

## 6. Flat vs Nested node\_modules (Important!)

Before npm v3, the structure was deeply nested:

```
node_modules/
  A/
    node_modules/
      B/
        node_modules/
          C/
```

With npm v3+, npm tries to **flatten** dependencies:

```
node_modules/
  A/
  B/
  C/
```

But flattening depends on:

* version compatibility
* peer dependency rules
* name conflicts

So even with npm v9+, some nested structures are still required.

## 7. Why Multiple Versions of the Same Package Can Exist

Suppose:

* Package A requires lodash v4
* Package B requires lodash v3

npm must install both:

```
node_modules/
  lodash/ (v4)
  A/node_modules/lodash (v4)
  B/node_modules/lodash (v3)
```

npm guarantees **isolation** so each dependency gets the correct version.

## 8. Deep Dependency Trees Explained

Let’s say you install:

```
npm install express
```

Express depends on Body-Parser.\
Body-Parser depends on qs, bytes, and many small libraries.

This produces a tree:

```
express
  ├─ accepts
  ├─ body-parser
  │   ├─ bytes
  │   ├─ qs
  │   └─ raw-body
  ├─ cookie
  ├─ debug
  ├─ depd
  └─ ...
```

You only installed _one_ package, but you got 50+ because dependencies chain together.

This is normal and expected.

## 9. The Hidden Files Inside Packages

Inside each package folder, you’ll find:

### `package.json`

Contains metadata, version, dependencies, entry points.

### `index.js` or main entry file

The file Node will run when you import the package.

### `dist` or `lib`

Compiled or minified production code.

### `src`

Original source code (not always included.)

### TypeScript definition files

Files ending in `.d.ts` for type checking.

### README.md

Documentation.

### LICENSE

License information.

## 10. Why Your Code Cannot Modify node\_modules

`node_modules` is:

* automatically generated
* overwritten during `npm install`
* removed when reinstalling
* ignored in GitHub

If you manually edit a file:

* your changes disappear during the next install
* teammates won't get your modifications
* deployment platforms will never see them

Instead:

* fork the package
* patch it using `patch-package`
* or submit a pull request

## 11. How node\_modules Works in Production Deployments

When deploying to:

* Vercel
* Netlify
* Railway
* AWS Lambda
* Docker

The `node_modules` folder is **rebuilt** on the server:

1. Server installs exact versions from package-lock.json
2. npm recreates node\_modules
3. build scripts run

This is why `package-lock.json` should always be committed.

## 12. The Problem of Node Modules Bloat

Large node\_modules causes:

* slow CI builds
* slow Docker image creation
* large disk usage
* long install times

To reduce size:

* remove unused dependencies
* use fewer packages
* use pnpm or yarn with deduping
* use workspaces
* avoid unnecessary heavy libraries

pnpm reduces node\_modules size by 60-80% using symlinks.

## 13. How pnpm Stores Dependencies Differently (Important Modern Concept)

pnpm uses a completely different model:

* All packages are stored once in a global content-addressable store
* Projects reference them using symlinks
* No duplication
* Much smaller node\_modules
* Much faster installs

Example structure:

```
node_modules/
  .pnpm/
    express@4.19.0/
    body-parser@1.20.2/
```

This is why pnpm is popular in large-scale applications.

## 14. Why node\_modules Should Never Be Committed to Git

Reasons:

* Too large
* Automatically generated
* OS-dependent
* May contain binaries
* Causes merge conflicts
* Deployment systems rebuild it anyway

Always add to `.gitignore`:

```
node_modules/
```

## 15. The Relationship Between node\_modules and package.json

In summary:

* `package.json` lists _what_ you want
* `package-lock.json` locks _exact versions_
* `node_modules` holds _the actual code_

If any two of these disagree:

* reinstalling node\_modules fixes it
* deleting node\_modules and reinstalling resolves conflicts

## 16. How npm Rebuilds node\_modules

If your node\_modules breaks or becomes corrupted:

```
rm -rf node_modules
npm install
```

This reconstructs everything using the lockfile.

## 17. Understanding the Performance Cost of node\_modules

Installing dependencies is often the **slowest part** of:

* onboarding
* CI/CD pipelines
* Docker builds

Typical performance issues include:

* packages with heavy native binaries
* post-install scripts
* deeply nested trees
* unnecessary dependencies

Use tools like `npm ls --depth=0` to audit installed packages.

## 18. Common Errors Related to node\_modules

### 1. Missing module

```
Error: Cannot find module 'express'
```

Solution:

```
npm install
```

### 2. Corrupted node\_modules

Solution:

```
rm -rf node_modules
npm install
```

### 3. Version mismatch

Occurs when dependencies expect different versions.

### 4. Permission issues (Linux/Mac)

Often solved by clearing cache:

```
npm cache clean --force
```

## 19. Best Practices When Working With node\_modules

* Do not edit files manually
* Always commit package-lock.json
* Never commit node\_modules
* Keep dependency count low
* Use exact versions for production
* Use pnpm for monorepos or large projects
* Remove unused packages regularly
* Run `npm audit` often
* Use tools like `depcheck` to find unused dependencies

## 20. Summary

In this chapter, you learned:

* What node\_modules is
* Why it becomes huge
* How Node resolves modules
* Why multiple versions of a package exist
* What the folder structure means
* Why you should never modify node\_modules manually
* How deployment systems rebuild dependencies
* How pnpm solves node\_modules bloat
* How to fix common errors
* Best practices for working with dependencies

This understanding is crucial for managing real-world JavaScript projects effectively.
